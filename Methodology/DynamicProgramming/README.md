# Dynamic Programming
>   다음 값을 계산하기 위해 이전에 계산한 값을 저장해두었다 다시 재활용 하는 방법 (Save & Reuse).
>   >   ex) 피보나치 수열 F(n) = F(n - 1) + F(n - 2)

## 점화식을 이끌어 내는 것이 중요
>   테스트 케이스를 작성해보면서 규칙을 파악.
## 유명 DP 알고리즘 

### 다익스트라 알고리즘
>   양의 가중치를 가지는 단방향 그래프에서 시작점이 주어진 경우, 시작점에서 모든 정점까지의 최단거리를 구하는 알고리즘.
1. 초기값 설정
2. 방문하지 않은 정점들 중 현재 최단 거리 값을 가지는 정점을 선택
3. 선택한 정점에가 갈 수 있는 정점들 중 방문되지 않은 정점들의 최단 거리 값을 업데이트
4. 모든 노드가 방문될 때 까지 2, 3을 반복

#### 배열을 이용하는 방법
>   1. 시작 정점의 dist 값과 시작 정점에서 갈 수 있는 정점의 dist 값을 업데이트 후 시작 정점 방문 처리
>   2. 방문되지 않은 정점들 중에서 최단거리 값을 가지는 정점 선택 후 방문처리
>   3. 선택된 정점과 이어진 정점들 중 방문되지 않은 정점들의 최단 거리 값을 업데이트

#### 최소 힙을 사용하는 방법
>   1. 시작 정점 dist 값 0 이외의 정점 dist 값 INF 처리 후 시작 정점과 해당 최단 거리 값을 최소 힙에 푸시
>   2. 힙에서 정점을 꺼냄\
    단, 힙에서 꺼낸 최단거리 값이 dist의 최단 거리 값보다 크다면 continue\
    왜냐하면, 이 뜻은 다른 정점에서 해당 정점으로 이동하는 최단거리 값이 업데이트 되었다는 것을 의미하기 때문에 확인할 필요가 없음.
>   3. 선택된 정점과 연결된 정점들의 최단 거리 값을 업데이트하고, 최단 거리 값이 업데이트 된다면 힙에 푸시

### 벨만포드 알고리즘
>   음수 간선이 존재하는 단방향 그래프에서 시작점이 주어진 경우, 시작점에서 모든 정점까지의 최단거리를 구하는 알고리즘.
>   >   음수 간선이 있는 경우에는 다익스트라는 최단 경로를 찾지 못함\
>   >   매 단계마다 그래프에 존재하는 모든 간선들을 확인하고 정점들의 최단 거리 값을 업데이트\
>   >   시작 정점 값은 0으로 초기화 후 (정점 개수 - 1) 만큼만 수행하면 모든 최단 거리 값을 확인 가능\
__하지만, 음의 가중치로 인해 최단 거리가 계속 업데이트 될 수 있어 n번째에 값이 업데이트 되는 것을 체크해서 음의 값을 가지는 것이 없는지 체크하는 것이 요구된다.__

### 플로이드 워셜 알고리즘
>   모든 시작 정점에서 모든 정점까지의 최단 거리를 구하는 알고리즘.
>   >   핵심은, 모든 정점을 경유하는 경우의 수를 고려함
>   >   dp[시작점][도착점] = min(dp[시작점][도착점], dp[시작점][경유지] + dp[경유지][도착점])